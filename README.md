# lab6

ОТЧЕТ ПО 6 ЛАБОРАТОРНОЙ РАБОТЕ
1. Формулировка задачи

Кот мяукает.
Создайте сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
• Может помяукать N раз, что приводит к выводу на экран следующего текста: “Имя: мяумяу-…-мяу!”, где количество “мяу”равно N.
Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза.
2 Интерфейс Мяуканье.
Разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у
каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
public void meow();
Дополните решение предыдущей задачи так, чтобы иметь возможность передать Кота в написанный
вами метод и протестируйте работоспособность решения передав в него нескольких котов, а также
создайте любой другой произвольный класс и передайте в написанный метод его объекты.
3 Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из предыдущего
задания. Необходимо таким образом передать кота в указанный метод, что бы после окончания его
работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед
вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы
выводим количество мяуканий на экран. Кота изменять нельзя.


2.1. Тест 1: Базовый функционал класса Cat
Описание: Проверка создания кота и его мяуканья

Шаги выполнения:

Создать кота с именем "Барсик"

Вызвать Meow() один раз

Вызвать Meow(3) для тройного мяуканья

Ожидаемый результат:

-----1-----
Барсик: мяу!

Барсик: мяу-мяу-мяу!

Фактический результат: Совпадает

Проблемы: Нет



2.2. Тест 2: Работа с интерфейсом MAAAO
Описание: Проверка полиморфизма через статический метод

Шаги выполнения:

Создать двух котов: "Барсик" и "Мурзик"

Создать объект KEsha

Передать всех в метод MeowsCare()

Ожидаемый результат:

-----2-----

Барсик: мяу!

Мурзик: мяу!

Иннокентий : мяяууууу...

Фактический результат: Совпадает



2.3. Тест 3: Подсчет мяуканий через декоратор
Описание: Проверка работы паттерна Decorator

Шаги выполнения:

Создать кота "Снежок"

Обернуть в MeowCounter

Передать 5 одинаковых ссылок в MeowsCare

Вывести счетчик

Ожидаемый результат:

-----3-----

Снежок: мяу!

Снежок: мяу!

Снежок: мяу!

Снежок: мяу!

Снежок: мяу!

Кот мяукал 5 раз

Фактический результат: Совпадает

Важное замечание:

В список передаются 5 ссылок на один и тот же объект counter

Каждая ссылка вызывает Meow() у одного объекта

Counter.Count увеличивается на 1 при каждом вызове

Итого: 5 вызовов = Count = 5


3. ДЕТАЛЬНЫЙ АНАЛИЗ РАБОТЫ ПРОГРАММЫ
3.1. Последовательность выполнения
   
1. Запуск программы
2. Вывод "-----1-----"
3. Создание Cat("Барсик")
4. barsik.Meow() → "Барсик: мяу!"
5. barsik.Meow(3) → "Барсик: мяу-мяу-мяу!"
6. Вывод "-----2-----"
7. Создание Cat("Мурзик")
8. Создание KEsha()
9. Funs.MeowsCare([barsik, murzik, kesha]):
   - barsik.Meow() → "Барсик: мяу!" (повторно)
   - murzik.Meow() → "Мурзик: мяу!"
   - kesha.Meow() → "Иннокентий : мяяууууу..."
10. Вывод "-----3-----"
11. Создание Cat("Снежок")
12. Обертывание в MeowCounter(snow)
13. Создание Enumerable.Repeat(counter, 5) - 5 одинаковых ссылок
14. Funs.MeowsCare([counter, counter, counter, counter, counter]):
    - counter.Meow() → Count=1, snow.Meow() → "Снежок: мяу!"
    - counter.Meow() → Count=2, snow.Meow() → "Снежок: мяу!"
    - counter.Meow() → Count=3, snow.Meow() → "Снежок: мяу!"
    - counter.Meow() → Count=4, snow.Meow() → "Снежок: мяу!"
    - counter.Meow() → Count=5, snow.Meow() → "Снежок: мяу!"
15. Вывод "Кот мяукал 5 раз"

Задача 2

Дроби.
Создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Может выполнять операции сложения, вычитания, умножения и деления с другой
Дробью или целым числом. Результатом операции должна быть новая Дробь (таким
образом, обе исходные дроби не изменяются) (Обязательно использовать перегрузки!)
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не
может быть отрицательным.
Затем необходимо выполнить следующие задачи:
1. Создать несколько экземпляров дробей.
2. Написать по одному примеру использования каждого метода.
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9»
4. Посчитать f1.sum(f2).div(f3).minus(5)
2 Сравнение дробей.
Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
3 Клонирование дроби. Интерфейс ICloneable.
Переопределите метод клонирования, таким образом, чтобы при его вызове возвращался новый
объект Дроби, значения полей которого будут копиями оригинальной Дроби.
4 В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.

ОТЧЕТ
Лабораторная работа № [номер]
Тема: Реализация класса для работы с дробями в C#

Выполнил: [Ваше имя]
Группа: [Номер группы]
Дата: [Дата выполнения]

1. ЦЕЛЬ РАБОТЫ
Разработка класса Fraction для представления математических дробей с реализацией основных арифметических операций, сравнения и преобразования.

2. ЗАДАЧИ
Создать класс Fraction с полями для числителя и знаменателя

Реализовать проверку корректности данных (знаменатель ≠ 0)

Реализовать основные арифметические операции (+, -, *, /)

Обеспечить автоматическое сокращение дробей

Реализовать кэширование десятичного значения

Обеспечить возможность сравнения дробей

3. РЕАЛИЗАЦИЯ
3.1. Структура класса
   
Класс содержит:

Приватные поля: numerator, denominator, cachedValue

Публичные свойства с валидацией

Конструктор с проверкой знаменателя

3.2. Ключевые методы
Арифметические операции:

csharp
public static Fraction operator +(Fraction a, Fraction b)

public static Fraction operator -(Fraction a, Fraction b)

public static Fraction operator *(Fraction a, Fraction b)

public static Fraction operator /(Fraction a, Fraction b)


Вспомогательные методы:

GCD() - вычисление наибольшего общего делителя

Reduce() - сокращение дроби

CommonDenominator() - приведение к общему знаменателю

3.3. Особенности реализации

Кэширование - значение дроби в десятичном виде вычисляется один раз

Автоматическое сокращение - после каждой операции дробь приводится к несократимому виду

Валидация - знаменатель всегда положительный


4. ТЕСТИРОВАНИЕ
   
4.1. Тестовые примеры

Создание дробей:

var f1 = new Fraction(1, 2);    // 1/2
var f2 = new Fraction(3, 4);    // 3/4
var f3 = new Fraction(2, 4);    // автоматически сокращается до 1/2

Арифметические операции:

var sum = f1 + f2;      // 1/2 + 3/4 = 5/4
var diff = f2 - f1;     // 3/4 - 1/2 = 1/4
var prod = f1 * f2;     // 1/2 * 3/4 = 3/8
var quot = f2 / f1;     // 3/4 ÷ 1/2 = 3/2
Сравнение:

bool equal = f1.Equals(f3);    // true (1/2 == 2/4)


4.2. Обработка ошибок

// Попытка создать дробь с нулевым знаменателем
try { new Fraction(1, 0); }
catch (ArgumentException e) { /* обработано */ }

try { var result = f1 / new Fraction(0, 1); }
catch (DivideByZeroException e) { /* обработано */ }
5. РЕЗУЛЬТАТЫ
5.1. Достигнутые цели
Создан полностью функциональный класс Fraction
Реализованы все требуемые арифметические операции
Обеспечена корректная обработка ошибок
Реализовано автоматическое сокращение дробей
Добавлено кэширование для повышения производительности


